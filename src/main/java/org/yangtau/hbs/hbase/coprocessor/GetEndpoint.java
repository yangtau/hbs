package org.yangtau.hbs.hbase.coprocessor;

import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.ConnectionFactory;
import org.apache.hadoop.hbase.client.Get;
import org.apache.hadoop.hbase.client.Put;
import org.apache.hadoop.hbase.client.ServiceCaller;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.regionserver.Region;
import org.apache.hadoop.hbase.util.Bytes;
import org.yangtau.hbs.Constants;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class GetEndpoint extends GetProtos.GetService implements HBSCoprocessor {
    private RegionCoprocessorEnvironment env;

    // run Get request on the coprocessor
    static public CompletableFuture<GetProtos.GetResponse> runAsync(
            final Configuration conf, String table, GetProtos.GetRequest request) {
        ServiceCaller<Stub, GetProtos.GetResponse> get =
                (stub, controller, callback) -> stub.get(controller, request, callback);

        return ConnectionFactory.createAsyncConnection(conf)
                .thenApplyAsync(con -> con.getTable(TableName.valueOf(table)))
                .thenComposeAsync(t ->
                        t.coprocessorService(GetProtos.GetService::newStub, get, request.getRow().toByteArray())
                );
    }

    static public GetProtos.GetResponse run(final Configuration conf, String table, GetProtos.GetRequest request)
            throws InterruptedException, ExecutionException {
        return runAsync(conf, table, request).get();
    }

    @Override
    public void start(CoprocessorEnvironment env) throws IOException {
        if (env instanceof RegionCoprocessorEnvironment)
            this.env = (RegionCoprocessorEnvironment) env;
        else
            throw new CoprocessorException("Must be loaded on a table region!");
    }

    @Override
    public Iterable<Service> getServices() {
        return Collections.singleton(this);
    }


    /***************************************************************************
     * Algorithm of Get:
     * data mode: key -> (value, WT, RT, C)
     * get(key, TS):
     *     version =  max(c.WT if c.WT < TS for c in data[key])
     *     cell = for c in data[key] where c.WT == version
     *     if cell.RT < TS:
     *         cell.RT = TS
     *     return cell
     */
    @Override
    public void get(RpcController controller, GetProtos.GetRequest request, RpcCallback<GetProtos.GetResponse> done) {
        Region region = env.getRegion();
        byte[] row = request.getRow().toByteArray();
        byte[] family = request.getColumn().toByteArray();
        long requestTs = request.getTimestamp();

        // RT and WT for the data cell to be read
        long readTs = -1;
        long writeTs = -1;
        byte[] data = null;
        boolean committed = true;

        try {
            Get get = new Get(row)
                    .addFamily(family)
                    .setTimeRange(0, requestTs) // read in [0, requestTs)
                    .readVersions(1); // read the last version

            Region.RowLock lock = getLock(region, row);
            try {
                // TODO: get(get, false) doest not invoke other coprocessors
                for (Cell c : region.get(get, false)) {
                    byte[] qualifier = c.getQualifierArray();
                    byte[] value = c.getValueArray();
                    if (Arrays.equals(qualifier, Constants.ReadTimestampQualifierBytes)) {
                        readTs = Bytes.toLong(value);
                    } else if (Arrays.equals(qualifier, Constants.DataQualifierBytes)) {
                        data = value;
                        writeTs = c.getTimestamp();  // read the version of this data cell
                    } else if (Arrays.equals(qualifier, Constants.CommitQualifierBytes)) {
                        committed = false;
                    }
                }

                // read something, and this read has greater Ts than what has been recorded (readTs)
                // put(col: "$family:@RT", value: Ts, version: writeTs)
                if (readTs < requestTs && data != null) {
                    Put put = new Put(row, writeTs)
                            .addColumn(family, Constants.ReadTimestampQualifierBytes, Bytes.toBytes(requestTs));
                    region.put(put);
                }
            } finally {
                releaseLock(region, lock);
            }

            // do callback after releasing locks
            var rsp = GetProtos.GetResponse.newBuilder().setError(false);
            if (data != null) {
                rsp.setCommitted(committed)
                        .setTimestamp(writeTs) // version of the data gotten, thus the writeTimestamp
                        .setValue(ByteString.copyFrom(data));
            }
            done.run(rsp.build());
        } catch (IOException e) {
            done.run(GetProtos.GetResponse.newBuilder()
                    .setError(true)
                    .setErrorMsg(e.toString())
                    .build());
        }
    }
}
