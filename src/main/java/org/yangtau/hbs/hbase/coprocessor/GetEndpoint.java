package org.yangtau.hbs.hbase.coprocessor;

import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.Cell;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.*;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.regionserver.Region;
import org.apache.hadoop.hbase.util.Bytes;
import org.yangtau.hbs.Constants;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class GetEndpoint extends GetProtos.GetService implements RegionCoprocessor {
    private RegionCoprocessorEnvironment env;

    // run Get request on the coprocessor
    static public CompletableFuture<GetProtos.GetResponse> runAsync(
            final Configuration conf, String table, GetProtos.GetRequest request) {
        ServiceCaller<Stub, GetProtos.GetResponse> get =
                (stub, controller, callback) -> stub.get(controller, request, callback);

        return ConnectionFactory.createAsyncConnection(conf)
                .thenApplyAsync(con -> con.getTable(TableName.valueOf(table)))
                .thenComposeAsync(t ->
                        t.coprocessorService(GetProtos.GetService::newStub, get, request.getRow().toByteArray())
                );
    }

    static public GetProtos.GetResponse run(final Configuration conf, String table, GetProtos.GetRequest request)
            throws InterruptedException, ExecutionException {
        return runAsync(conf, table, request).get();
    }

    @Override
    public void start(CoprocessorEnvironment env) throws IOException {
        if (env instanceof RegionCoprocessorEnvironment)
            this.env = (RegionCoprocessorEnvironment) env;
        else
            throw new CoprocessorException("Must be loaded on a table region!");
    }

    @Override
    public void stop(CoprocessorEnvironment env) {
        // do noting
    }

    @Override
    public Iterable<Service> getServices() {
        return Collections.singleton(this);
    }

    private void fillResponse(Cell c, GetProtos.GetResponse.Builder builder) {

    }

    @Override
    public void get(RpcController controller, GetProtos.GetRequest request, RpcCallback<GetProtos.GetResponse> done) {
        Region region = env.getRegion();
        GetProtos.GetResponse.Builder rsp = GetProtos.GetResponse.newBuilder().setError(false).setCommitted(true);
        byte[] row = request.getRow().toByteArray();
        byte[] family = request.getColumn().toByteArray();
        long txnTs = request.getTimestamp();

        long readTs = -1;
        long writeTs = -1;

        try {
            Get get = new Get(row)
                    .addFamily(family)
                    .setTimeRange(0, txnTs) // read in [0, txnTs)
                    .readVersions(1); // read the last version

            region.startRegionOperation();
            Region.RowLock lock = region.getRowLock(row, false);
            try {
                // TODO: get(get, false) doest not invoke other coprocessors
                for (Cell c : region.get(get, false)) {
                    assert Arrays.equals(family, c.getFamilyArray()) : "Must get data from this family";
                    byte[] qualifier = c.getQualifierArray();
                    byte[] value = c.getValueArray();
                    if (Arrays.equals(qualifier, Constants.ReadTimestampQualifierBytes))
                        readTs = Bytes.toLong(value);
                    else if (Arrays.equals(qualifier, Constants.DataQualifierBytes))
                        rsp.setValue(ByteString.copyFrom(value));
                    else if (Arrays.equals(qualifier, Constants.CommitQualifierBytes))
                        rsp.setCommitted(false);
                    writeTs = c.getTimestamp();
                }

                // read something, and this read has bigger readTs than what has been recorded (readTs)
                // put(col: "$family:@RT", value: txnTs, version: writeTs)
                if (readTs < txnTs && rsp.hasValue()) {
                    Put put = new Put(row, writeTs)
                            .addColumn(family, Constants.ReadTimestampQualifierBytes, Bytes.toBytes(txnTs));
                    region.put(put);
                }
            } finally {
                lock.release();
                region.closeRegionOperation();
            }

            // do callback after releasing locks
            done.run(rsp.build());
        } catch (IOException e) {
            done.run(rsp
                    .setError(true)
                    .setErrorMsg(e.toString())
                    .build());
        }
    }
}
