package org.yangtau.hbs.hbase.coprocessor;

import com.google.protobuf.ByteString;
import com.google.protobuf.RpcCallback;
import com.google.protobuf.RpcController;
import com.google.protobuf.Service;
import org.apache.hadoop.hbase.CoprocessorEnvironment;
import org.apache.hadoop.hbase.client.*;
import org.apache.hadoop.hbase.coprocessor.CoprocessorException;
import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;
import org.apache.hadoop.hbase.regionserver.Region;
import org.apache.hadoop.hbase.util.Bytes;
import org.yangtau.hbs.KeyValue;
import org.yangtau.hbs.hbase.Constants;
import org.yangtau.hbs.hbase.autogenerated.PutProtos;

import java.io.IOException;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

public class PutEndpoint extends PutProtos.PutService implements HBSCoprocessor {
    private RegionCoprocessorEnvironment env;

    // run Put request on the coprocessor
    static public CompletableFuture<Boolean> runAsync(
            AsyncTable<AdvancedScanResultConsumer> asyncTable, KeyValue.Key key, byte[] value, long timestamp) {
        var request = PutProtos.PutRequest.newBuilder()
                .setRow(ByteString.copyFrom(key.row()))
                .setColumn(ByteString.copyFrom(key.column()))
                .setValue(ByteString.copyFrom(value))
                .setTimestamp(timestamp)
                .build();

        ServiceCaller<Stub, PutProtos.PutResponse> put =
                (stub, controller, callback) -> stub.put(controller, request, callback);
        return asyncTable.coprocessorService(PutProtos.PutService::newStub, put, key.row())
                .thenApplyAsync(rsp -> {
                    if (rsp.getError())
                        throw new CompletionException(new IOException(rsp.getErrorMsg()));
                    return rsp.getResult();
                });
    }

    @Override
    public void start(CoprocessorEnvironment env) throws IOException {
        if (env instanceof RegionCoprocessorEnvironment)
            this.env = (RegionCoprocessorEnvironment) env;
        else
            throw new CoprocessorException("Must be loaded on a table region!");
    }

    @Override
    public Iterable<Service> getServices() {
        return Collections.singleton(this);
    }

    /***************************************************************************
     * Algorithm of Put:
     * data mode: key -> (value, WT, RT, C)
     * Put(key, value, TS):
     *     version =  max(c.WT if c.WT < TS for c in data[key])
     *     cell = for c in data[key] where c.WT == version
     *     if cell.RT > TS:
     *          abort
     *     data[key] = (value, TS, 0, false)
     */
    @Override
    public void put(RpcController controller, PutProtos.PutRequest request, RpcCallback<PutProtos.PutResponse> done) {
        Region region = env.getRegion();
        PutProtos.PutResponse.Builder rsp = PutProtos.PutResponse.newBuilder().setError(false).setResult(false);
        byte[] row = request.getRow().toByteArray();
        byte[] family = request.getColumn().toByteArray();
        byte[] value = request.getValue().toByteArray();
        long requestTs = request.getTimestamp();

        // the RT of the data of the last version in the row
        long readTs = -1;

        try {
            Get get = new Get(row)
                    .setTimeRange(0, requestTs)
                    .addFamily(family)
                    .readVersions(1);
            Put put = new Put(row, requestTs)
                    .addColumn(family, Constants.DATA_QUALIFIER_BYTES, value)
                    .addColumn(family, Constants.UNCOMMITTED_QUALIFIER_BYTES, Bytes.toBytes(""));

            Region.RowLock lock = getLock(region, row);
            try {
                // read the last version
                var res = region.get(get);
                var kv = res.getColumnLatestCell(family, Constants.DATA_QUALIFIER_BYTES);
                var rtCell = res.getColumnLatestCell(family, Constants.READ_TIMESTAMP_QUALIFIER_BYTES);
                // find RT of this data cell by its version
                if (kv != null && rtCell != null
                        && rtCell.getTimestamp() == kv.getTimestamp()) {
                    readTs = Bytes.toLong(rtCell.getValueArray());
                }

                if (readTs <= requestTs) {
                    // no conflicts
                    region.put(put);
                    rsp.setResult(true);
                }
            } finally {
                releaseLock(region, lock);
            }

            done.run(rsp.build());
        } catch (IOException e) {
            done.run(rsp
                    .setError(true)
                    .setErrorMsg(e.toString())
                    .build());
        }
    }
}
