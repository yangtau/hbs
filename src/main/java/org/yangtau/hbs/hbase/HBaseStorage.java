package org.yangtau.hbs.hbase;

import com.google.protobuf.ByteString;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.*;
import org.yangtau.hbs.Storage;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;
import org.yangtau.hbs.hbase.autogenerated.PutProtos;
import org.yangtau.hbs.hbase.coprocessor.GetEndpoint;
import org.yangtau.hbs.hbase.coprocessor.PutEndpoint;

import java.util.List;
import java.util.concurrent.CompletableFuture;

// Implementation of Storage in HBase
public class HBaseStorage implements Storage {
    private final AsyncConnection connection;

    public HBaseStorage(AsyncConnection conn) {
        connection = conn;
    }

    @Override
    public CompletableFuture<Void> createTable(String table, List<byte[]> cols, boolean multiVersion) {
        var builder = TableDescriptorBuilder.newBuilder(TableName.valueOf(table));

        for (var col : cols) {
            var columnBuilder = ColumnFamilyDescriptorBuilder.newBuilder(col);
            if (multiVersion)
                columnBuilder.setMaxVersions(Integer.MAX_VALUE).setTimeToLive(Integer.MAX_VALUE);
            builder.setColumnFamily(columnBuilder.build());
        }

        return connection.getAdmin()
                .createTable(builder.build());
    }

    @Override
    public CompletableFuture<Void> removeTable(String table) {
        var tableName = TableName.valueOf(table);
        var admin = connection.getAdmin();
        return admin.disableTable(tableName)
                .thenComposeAsync(v -> admin.deleteTable(tableName));
    }

    @Override
    public CompletableFuture<Void> put(String table, byte[] row, byte[] col, byte[] value) {
        var put = new Put(row)
                .addColumn(col, Constants.DataQualifierBytes, value);
        return connection
                .getTable(TableName.valueOf(table))
                .put(put);
    }

    @Override
    public CompletableFuture<byte[]> get(String table, byte[] row, byte[] col) {
        var get = new Get(row)
                .addColumn(col, Constants.DataQualifierBytes);
        return connection
                .getTable(TableName.valueOf(table))
                .get(get)
                .thenApplyAsync((r) -> r.getValue(col, Constants.DataQualifierBytes));
    }

    @Override
    public CompletableFuture<Boolean> exists(String table, byte[] row, byte[] col) {
        var get = new Get(row)
                .setCheckExistenceOnly(true)
                .addColumn(col, Constants.DataQualifierBytes);
        return connection
                .getTable(TableName.valueOf(table))
                .exists(get);
    }

    @Override
    public CompletableFuture<Void> remove(String table, byte[] row, byte[] col) {
        var delete = new Delete(row).addFamily(col);
        return connection
                .getTable(TableName.valueOf(table))
                .delete(delete);
    }

    // Read data and record the newest read timestamp for each version.
    // In HBase, we use @GetEndpoint to implement this.
    @Override
    public CompletableFuture<Cell> getWithReadTimestamp(String table, byte[] row, byte[] col, long readTimestamp) {
        var request = GetProtos.GetRequest.newBuilder()
                .setRow(ByteString.copyFrom(row))
                .setColumn(ByteString.copyFrom(col))
                .setTimestamp(readTimestamp)
                .build();
        return GetEndpoint.runAsync(connection, table, row, request)
                .thenApply(
                        response -> {
                            if (response.getError() || !response.hasValue()) {
                                // TODO: log error message
                                return null;
                            }
                            return new Cell(response.getValue().toByteArray(),
                                    response.getCommitted(),
                                    response.getTimestamp());
                        }
                );
    }

    @Override
    public CompletableFuture<Boolean> putIfNoConflict(String table, byte[] row, byte[] col, byte[] value, long writeTimestamp) {
        var request = PutProtos.PutRequest.newBuilder()
                .setRow(ByteString.copyFrom(row))
                .setColumn(ByteString.copyFrom(col))
                .setValue(ByteString.copyFrom(value))
                .setTimestamp(writeTimestamp)
                .build();

        return PutEndpoint.runAsync(connection, table, row, request)
                .thenApplyAsync(
                        response -> {
                            if (response.getError()) {
                                // TODO: log error
                                return false;
                            }
                            return response.getResult();
                        }
                );
    }
}
