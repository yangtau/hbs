import com.google.protobuf.ByteString;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.util.Bytes;
import org.junit.jupiter.api.Test;
import org.yangtau.hbs.Constants;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;
import org.yangtau.hbs.hbase.coprocessor.GetEndpoint;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;


class GetEndpointTest {
    private final Configuration conf = HBaseConfiguration.create();
    private final String tableName = "test";
    private final String family = "cf";

    private void expectGet(String row, long ts, byte[] expectValue, long expectVersion, boolean expectCommitted)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg());
        assertTrue(rsp.hasValue());
        assertTrue(Arrays.equals(rsp.getValue().toByteArray(), expectValue));
        assertEquals(expectVersion, rsp.getTimestamp());
        assertEquals(expectCommitted, rsp.getCommitted());
    }

    private void expectGetEmpty(String row, long ts)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg());
        assertFalse(rsp.hasValue());
    }

    // check read timestamp
    private void checkReadTimestamp(String row, long version, long expectRt)
            throws ExecutionException, InterruptedException, IOException {
        var res = TestUtil.get(conf, tableName, row, version, family);
        assertTrue(res.containsColumn(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes));
        assertEquals(expectRt,
                Bytes.toLong(res.getValue(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes)));
    }

    // check if there is no read timestamp
    private void checkNoReadTimestamp(String row, long version)
            throws ExecutionException, InterruptedException, IOException {
        var res = TestUtil.get(conf, tableName, row, version, family);
        assertFalse(res.containsColumn(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes));
    }


    @Test
    void getCommittedAndUncommitted() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);
        var value = "hello";

        // Read uncommitted
        // get with a small ts, no RT should be written
        TestUtil.put(conf, tableName, "row1", 1L, family, Constants.DataQualifier, value);
        TestUtil.put(conf, tableName, "row1", 1L, family, Constants.CommitQualifier, "");
        checkNoReadTimestamp("row1", 1L);
        // nothing should be read
        expectGetEmpty("row1", 1L);
        checkNoReadTimestamp("row1", 1L);
        // expect write a (RT: 2L) in version 1L
        expectGet("row1", 2L, Bytes.toBytes(value), 1L, false);
        checkReadTimestamp("row1", 1L, 2L);

        // Read committed
        TestUtil.put(conf, tableName, "row1", 3L, family, Constants.DataQualifier, value);
        checkNoReadTimestamp("row1", 3L);
        // expect write a (RT: 4L) in version 3L
        expectGet("row1", 4L, Bytes.toBytes(value), 3L, true);
        checkReadTimestamp("row1", 3L, 4L);

        // TestUtil.DeleteTable(conf, tableName, family);
    }

    @Test
    void getFromMultiVersions() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        String row = "row100";
        long length = 20;
        Map<Long, byte[]> versionToValue = new HashMap<>();
        var random = new Random();

        for (long i = 0L; i < length; i += 3L) {
            var ts = Math.abs(random.nextLong()) % length;
            var value = random.nextDouble() + "";
            TestUtil.put(conf, tableName, row, ts, family, Constants.DataQualifier, value);
            versionToValue.put(ts, Bytes.toBytes(value));
        }


        for (long i = 0L; i < length + 1L; i++) {
            final var ts = i;
            var opt = versionToValue.entrySet().stream()
                    .filter(e -> e.getKey() < ts)
                    .max((e1, e2) -> (int) (e1.getKey() - e2.getKey()));

            if (opt.isEmpty()) {
                expectGetEmpty(row, ts);
            } else {
                expectGet(row, ts, opt.get().getValue(), opt.get().getKey(), true);
            }
        }
    }

    @Test
    void multiGetOnTheSameData() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        // version 20
        String row = "favorite programming language";
        String value20 = "hedgehog";
        long writeTs20 = 20L;
        TestUtil.put(conf, tableName, row, writeTs20, family, Constants.DataQualifier, value20);

        // version 15
        String value15 = "lisp";
        long writeTs15 = 15L;
        TestUtil.put(conf, tableName, row, writeTs15, family, Constants.DataQualifier, value15);

        checkNoReadTimestamp(row, writeTs15);
        checkNoReadTimestamp(row, writeTs20);

        // case 1: no RT before
        {
            // get version 15
            expectGet(row, 20, Bytes.toBytes(value15), 15, true);
            checkReadTimestamp(row, 15, 20);
            // get version 20
            expectGet(row, 30, Bytes.toBytes(value20), 20, true);
            checkReadTimestamp(row, 20, 30);
        }
        // case 2: smaller RT than current one
        // WT  RT
        // 20  30
        // 15  20
        {
            // get version 15
            expectGet(row, 19, Bytes.toBytes(value15), 15, true);
            checkReadTimestamp(row, 15, 20);
            // get version 20
            expectGet(row, 21, Bytes.toBytes(value20), 20, true);
            checkReadTimestamp(row, 20, 30);
        }
        // case 3: bigger RT than current one
        // WT  RT
        // 20  30
        // 15  20
        {
            // get version 20
            expectGet(row, 31, Bytes.toBytes(value20), 20, true);
            checkReadTimestamp(row, 20, 31);
        }
    }

    @Test
    void randomGet() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        String row = "row100";
        long maxTs = 20;
        Map<Long, byte[]> versionToValue = new HashMap<>();
        Map<Long, Long> maxRts = new HashMap<>();
        var random = new Random();

        // prepared data in the `row`
        for (long i = 0L; i < maxTs; i += 3L) {
            var ts = Math.abs(random.nextLong()) % maxTs;
            var value = random.nextDouble() + "";
            TestUtil.put(conf, tableName, row, ts, family, Constants.DataQualifier, value);
            versionToValue.put(ts, Bytes.toBytes(value));
        }


        for (long i = 0L; i < maxTs * 2; i++) {
            var ts = Math.abs(random.nextLong()) % (maxTs * 2);

            // the version will be read
            var opt = versionToValue.entrySet().stream()
                    .filter(e -> e.getKey() < ts)
                    .max((e1, e2) -> (int) (e1.getKey() - e2.getKey()));
            if (opt.isEmpty()) {
                // nothing can be read, the ts is too small
                expectGetEmpty(row, ts);
            } else {
                var writeTs = opt.get().getKey();
                var value = opt.get().getValue();

                // check RT before Get
                if (!maxRts.containsKey(writeTs)) {
                    // no read on this version before
                    checkNoReadTimestamp(row, writeTs);
                }

                expectGet(row, ts, value, writeTs, true);
                if (!maxRts.containsKey(writeTs)) {
                    // no read on this version before
                    maxRts.put(writeTs, ts);
                    checkReadTimestamp(row, writeTs, ts);
                } else {
                    var preRt = maxRts.get(writeTs);
                    var curRt = preRt > ts ? preRt : ts;
                    maxRts.put(writeTs, curRt);
                    checkReadTimestamp(row, writeTs, curRt);
                }

            }
        }
    }

}
