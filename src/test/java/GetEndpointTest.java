import com.google.protobuf.ByteString;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.util.Bytes;
import org.junit.jupiter.api.Test;
import org.yangtau.hbs.Constants;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;
import org.yangtau.hbs.hbase.coprocessor.GetEndpoint;

import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;


class GetEndpointTest {
    private final Configuration conf = HBaseConfiguration.create();
    private final String tableName = "test";
    private final String family = "cf";

    private void expectGet(String row, long ts, byte[] expectValue, long expectVersion, boolean expectCommitted)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg());
        assertTrue(rsp.hasValue());
        assertTrue(Arrays.equals(rsp.getValue().toByteArray(), expectValue));
        assertEquals(rsp.getTimestamp(), expectVersion);
        assertEquals(rsp.getCommitted(), expectCommitted);
    }

    private void expectGetEmpty(String row, long ts)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg());
        assertFalse(rsp.hasValue());
    }

    // check read timestamp
    private void checkReadTimestamp(String row, long version, long expectRt)
            throws ExecutionException, InterruptedException, IOException {
        var res = TestUtil.get(conf, tableName, row, version, family);
        assertTrue(res.containsColumn(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes));
        assertEquals(expectRt,
                Bytes.toLong(res.getValue(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes)));
    }

    // check if there is no read timestamp
    private void expectNoReadTimestamp(String row, long version)
            throws ExecutionException, InterruptedException, IOException {
        var res = TestUtil.get(conf, tableName, row, version, family);
        assertFalse(res.containsColumn(Bytes.toBytes(family), Constants.ReadTimestampQualifierBytes));
    }


    @Test
    void getCommittedAndUncommitted() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName, family);
        TestUtil.CreateTable(conf, tableName, family);
        var value = "hello";

        // Read uncommitted
        // get with a small ts, no RT should be written
        TestUtil.put(conf, tableName, "row1", 1, family, Constants.DataQualifier, value);
        TestUtil.put(conf, tableName, "row1", 1, family, Constants.CommitQualifier, "");
        expectNoReadTimestamp("row1", 1);
        // nothing should be read
        expectGetEmpty("row1", 1);
        expectNoReadTimestamp("row1", 1);
        // expect write a (RT: 2) in version 1
        expectGet("row1", 2, Bytes.toBytes(value), 1, false);
        checkReadTimestamp("row1", 1, 2);

        // Read committed
        TestUtil.put(conf, tableName, "row2", 3, family, Constants.DataQualifier, value);
        expectNoReadTimestamp("row2", 3);
        // expect write a (RT: 4) in version 3
        expectGet("row2", 4, Bytes.toBytes(value), 3, true);
        checkReadTimestamp("row2", 3, 4);

        // TestUtil.DeleteTable(conf, tableName, family);
    }
}
