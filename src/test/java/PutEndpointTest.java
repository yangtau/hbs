import com.google.protobuf.ByteString;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.util.Bytes;
import org.junit.jupiter.api.Test;
import org.yangtau.hbs.hbase.coprocessor.Constants;
import org.yangtau.hbs.hbase.autogenerated.GetProtos;
import org.yangtau.hbs.hbase.autogenerated.PutProtos;
import org.yangtau.hbs.hbase.coprocessor.GetEndpoint;
import org.yangtau.hbs.hbase.coprocessor.PutEndpoint;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;

class PutEndpointTest {
    final String tableName = "test";
    final String family = "cf-put";
    final String row = "row";
    private final Configuration conf = HBaseConfiguration.create();

    boolean put(long ts, String value) throws ExecutionException, InterruptedException {
        var request = PutProtos.PutRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setValue(ByteString.copyFromUtf8(value))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();

        var res = PutEndpoint.run(conf, tableName, request);
        assertFalse(res.getError(), res.getErrorMsg());
        return res.getResult();
    }

    void check(long ts, String value, boolean committed) throws ExecutionException, InterruptedException, IOException {
        var res = TestUtil.get(conf, tableName, row, ts, family);
        assertTrue(Arrays.equals(res.getValue(Bytes.toBytes(family), Constants.DataQualifierBytes),
                Bytes.toBytes(value)));

        boolean c = !res.containsColumn(Bytes.toBytes(family), Constants.CommitQualifierBytes);
        assertEquals(committed, c);
    }

    void expectGet(long ts, byte[] expectValue, long expectVersion, boolean expectCommitted)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg() + " ts: " + ts);
        assertTrue(rsp.hasValue(), " ts: " + ts);
        assertTrue(Arrays.equals(rsp.getValue().toByteArray(), expectValue), " ts: " + ts);
        assertEquals(expectVersion, rsp.getTimestamp(), " ts: " + ts);
        assertEquals(expectCommitted, rsp.getCommitted(), " ts: " + ts);
    }

    void expectGetEmpty(long ts)
            throws ExecutionException, InterruptedException {
        var request = GetProtos.GetRequest.newBuilder()
                .setTimestamp(ts)
                .setRow(ByteString.copyFromUtf8(row))
                .setColumn(ByteString.copyFromUtf8(family))
                .build();
        var rsp = GetEndpoint.run(conf, tableName, request);
        assertFalse(rsp.getError(), rsp.getErrorMsg());
        assertFalse(rsp.hasValue());
    }


    @Test
    void putNoConflicts() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        Map<Long, String> versionToValue = new HashMap<>();
        var random = new Random();

        for (int i = 0; i < 10; i++) {
            var ts = Math.abs(random.nextLong()) % 20;
            if (versionToValue.containsKey(ts)) {
                continue;
            }

            var val = random.nextDouble() + "";
            versionToValue.put(ts, val);
            assertTrue(put(ts, val));
        }

        for (var e : versionToValue.entrySet()) {
            check(e.getKey(), e.getValue(), false);
        }
    }

    @Test
    void putConflict() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        assertTrue(put(1, "v1"));

        // T2(get, put)
        expectGet(2, Bytes.toBytes("v1"), 1, false);
        // no conflicts in on txn
        assertTrue(put(2, "v2"));

        // read version 2
        expectGet(5, Bytes.toBytes("v2"), 2, false);

        // try to put version 4
        assertFalse(put(4, "v4"));

        // read version 2
        expectGet(3, Bytes.toBytes("v2"), 2, false);
    }

    @Test
    void putAndGetRandomly() throws ExecutionException, InterruptedException, IOException {
        TestUtil.DeleteTable(conf, tableName);
        TestUtil.CreateTable(conf, tableName, family);

        Map<Long, String> versionToValue = new HashMap<>();
        Map<Long, Long> maxRts = new HashMap<>();
        var random = new Random();

        for (int i = 0; i < 20; i++) {
            var ts = Math.abs(random.nextLong()) % 20;
            var opt = versionToValue.entrySet().stream()
                    .filter(e -> e.getKey() < ts)
                    .max((e1, e2) -> (int) (e1.getKey() - e2.getKey()));

            if (random.nextBoolean()) {
                // get
                if (opt.isEmpty()) {
                    // nothing can be read, the ts is too small
                    expectGetEmpty(ts);
                } else {
                    var writeTs = opt.get().getKey();
                    var value = opt.get().getValue();

                    expectGet(ts, Bytes.toBytes(value), writeTs, false);
                    if (!maxRts.containsKey(writeTs)) {
                        // no read on this version before
                        maxRts.put(writeTs, ts);
                    } else {
                        var preRt = maxRts.get(writeTs);
                        var curRt = preRt > ts ? preRt : ts;
                        maxRts.put(writeTs, curRt);
                    }
                }
            } else {
                // put
                var value = random.nextDouble() + "";
                var conflict = opt.isPresent() && maxRts.getOrDefault(opt.get().getKey(), -1L) > ts;
                assertEquals(!conflict, put(ts, value), "put ts: " + ts);
                if (!conflict) {
                    versionToValue.put(ts, value);
                }
            }
        }
    }
}
